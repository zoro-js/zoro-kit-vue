webpackJsonp([3],{

/***/ 0:
/*!**************************************!*\
  !*** ./src/js/entry/vuex/counter.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(Vue) {'use strict';\n\nvar _Counter = __webpack_require__(/*! module/counter/Counter */ 51);\n\nvar _Counter2 = _interopRequireDefault(_Counter);\n\nvar _store = __webpack_require__(/*! module/counter/store */ 54);\n\nvar _store2 = _interopRequireDefault(_store);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nnew Vue({\n  store: _store2['default'],\n  render: function render(h) {\n    return h(_Counter2['default']);\n  }\n}).$mount('#app');\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! vue */ 1)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/entry/vuex/counter.js\n ** module id = 0\n ** module chunks = 3\n **/\n//# sourceURL=webpack:///./src/js/entry/vuex/counter.js?");

/***/ },

/***/ 48:
/*!*****************************!*\
  !*** ./~/vuex/dist/vuex.js ***!
  \*****************************/
/***/ function(module, exports, __webpack_require__) {

	eval("/**\n * vuex v2.0.0-rc.5\n * (c) 2016 Evan You\n * @license MIT\n */\n(function (global, factory) {\n   true ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Vuex = factory());\n}(this, function () { 'use strict';\n\n  var devtoolHook =\n    typeof window !== 'undefined' &&\n    window.__VUE_DEVTOOLS_GLOBAL_HOOK__\n\n  function devtoolPlugin (store) {\n    if (!devtoolHook) return\n\n    store._devtoolHook = devtoolHook\n\n    devtoolHook.emit('vuex:init', store)\n\n    devtoolHook.on('vuex:travel-to-state', function (targetState) {\n      store.replaceState(targetState)\n    })\n\n    store.subscribe(function (mutation, state) {\n      devtoolHook.emit('vuex:mutation', mutation, state)\n    })\n  }\n\n  function applyMixin (Vue) {\n    var version = Number(Vue.version.split('.')[0])\n\n    if (version >= 2) {\n      var usesInit = Vue.config._lifecycleHooks.indexOf('init') > -1\n      Vue.mixin(usesInit ? { init: vuexInit } : { beforeCreate: vuexInit })\n    } else {\n      // override init and inject vuex init procedure\n      // for 1.x backwards compatibility.\n      var _init = Vue.prototype._init\n      Vue.prototype._init = function (options) {\n        if ( options === void 0 ) options = {};\n\n        options.init = options.init\n          ? [vuexInit].concat(options.init)\n          : vuexInit\n        _init.call(this, options)\n      }\n    }\n\n    /**\n     * Vuex init hook, injected into each instances init hooks list.\n     */\n\n    function vuexInit () {\n      var options = this.$options\n      // store injection\n      if (options.store) {\n        this.$store = options.store\n      } else if (options.parent && options.parent.$store) {\n        this.$store = options.parent.$store\n      }\n    }\n  }\n\n  function mapState (states) {\n    var res = {}\n    normalizeMap(states).forEach(function (ref) {\n      var key = ref.key;\n      var val = ref.val;\n\n      res[key] = function mappedState () {\n        return typeof val === 'function'\n          ? val.call(this, this.$store.state, this.$store.getters)\n          : this.$store.state[val]\n      }\n    })\n    return res\n  }\n\n  function mapMutations (mutations) {\n    var res = {}\n    normalizeMap(mutations).forEach(function (ref) {\n      var key = ref.key;\n      var val = ref.val;\n\n      res[key] = function mappedMutation () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return this.$store.commit.apply(this.$store, [val].concat(args))\n      }\n    })\n    return res\n  }\n\n  function mapGetters (getters) {\n    var res = {}\n    normalizeMap(getters).forEach(function (ref) {\n      var key = ref.key;\n      var val = ref.val;\n\n      res[key] = function mappedGetter () {\n        if (!(val in this.$store.getters)) {\n          console.error((\"[vuex] unknown getter: \" + val))\n        }\n        return this.$store.getters[val]\n      }\n    })\n    return res\n  }\n\n  function mapActions (actions) {\n    var res = {}\n    normalizeMap(actions).forEach(function (ref) {\n      var key = ref.key;\n      var val = ref.val;\n\n      res[key] = function mappedAction () {\n        var args = [], len = arguments.length;\n        while ( len-- ) args[ len ] = arguments[ len ];\n\n        return this.$store.dispatch.apply(this.$store, [val].concat(args))\n      }\n    })\n    return res\n  }\n\n  function normalizeMap (map) {\n    return Array.isArray(map)\n      ? map.map(function (key) { return ({ key: key, val: key }); })\n      : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })\n  }\n\n  var Vue // bind on install\n\n  var Store = function Store (options) {\n    var this$1 = this;\n    if ( options === void 0 ) options = {};\n\n    assert(Vue, \"must call Vue.use(Vuex) before creating a store instance.\")\n    assert(typeof Promise !== 'undefined', \"vuex requires a Promise polyfill in this browser.\")\n\n    var state = options.state; if ( state === void 0 ) state = {};\n    var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];\n    var strict = options.strict; if ( strict === void 0 ) strict = false;\n\n    // store internal state\n    this._options = options\n    this._committing = false\n    this._actions = Object.create(null)\n    this._mutations = Object.create(null)\n    this._wrappedGetters = Object.create(null)\n      this._runtimeModules = Object.create(null)\n    this._subscribers = []\n    this._watcherVM = new Vue()\n\n    // bind commit and dispatch to self\n    var store = this\n    var ref = this;\n    var dispatch = ref.dispatch;\n    var commit = ref.commit;\n      this.dispatch = function boundDispatch (type, payload) {\n      return dispatch.call(store, type, payload)\n    }\n    this.commit = function boundCommit (type, payload, options) {\n      return commit.call(store, type, payload, options)\n    }\n\n    // strict mode\n    this.strict = strict\n\n    // init root module.\n    // this also recursively registers all sub-modules\n    // and collects all module getters inside this._wrappedGetters\n    installModule(this, state, [], options)\n\n    // initialize the store vm, which is responsible for the reactivity\n    // (also registers _wrappedGetters as computed properties)\n    resetStoreVM(this, state)\n\n    // apply plugins\n    plugins.concat(devtoolPlugin).forEach(function (plugin) { return plugin(this$1); })\n  };\n\n  var prototypeAccessors = { state: {} };\n\n  prototypeAccessors.state.get = function () {\n    return this._vm.state\n  };\n\n  prototypeAccessors.state.set = function (v) {\n    assert(false, \"Use store.replaceState() to explicit replace store state.\")\n  };\n\n  Store.prototype.commit = function commit (type, payload, options) {\n      var this$1 = this;\n\n    // check object-style commit\n    var mutation\n    if (isObject(type) && type.type) {\n      options = payload\n      payload = mutation = type\n      type = type.type\n    } else {\n      mutation = { type: type, payload: payload }\n    }\n    var entry = this._mutations[type]\n    if (!entry) {\n      console.error((\"[vuex] unknown mutation type: \" + type))\n      return\n    }\n    this._withCommit(function () {\n      entry.forEach(function commitIterator (handler) {\n        handler(payload)\n      })\n    })\n    if (!options || !options.silent) {\n      this._subscribers.forEach(function (sub) { return sub(mutation, this$1.state); })\n    }\n  };\n\n  Store.prototype.dispatch = function dispatch (type, payload) {\n    var entry = this._actions[type]\n    if (!entry) {\n      console.error((\"[vuex] unknown action type: \" + type))\n      return\n    }\n    return entry.length > 1\n      ? Promise.all(entry.map(function (handler) { return handler(payload); }))\n      : entry[0](payload)\n  };\n\n  Store.prototype.subscribe = function subscribe (fn) {\n    var subs = this._subscribers\n    if (subs.indexOf(fn) < 0) {\n      subs.push(fn)\n    }\n    return function () {\n      var i = subs.indexOf(fn)\n      if (i > -1) {\n        subs.splice(i, 1)\n      }\n    }\n  };\n\n  Store.prototype.watch = function watch (getter, cb, options) {\n      var this$1 = this;\n\n    assert(typeof getter === 'function', \"store.watch only accepts a function.\")\n    return this._watcherVM.$watch(function () { return getter(this$1.state); }, cb, options)\n  };\n\n  Store.prototype.replaceState = function replaceState (state) {\n      var this$1 = this;\n\n    this._withCommit(function () {\n      this$1._vm.state = state\n    })\n  };\n\n  Store.prototype.registerModule = function registerModule (path, module) {\n    if (typeof path === 'string') path = [path]\n    assert(Array.isArray(path), \"module path must be a string or an Array.\")\n    this._runtimeModules[path.join('.')] = module\n    installModule(this, this.state, path, module)\n    // reset store to update getters...\n    resetStoreVM(this, this.state)\n  };\n\n  Store.prototype.unregisterModule = function unregisterModule (path) {\n      var this$1 = this;\n\n    if (typeof path === 'string') path = [path]\n    assert(Array.isArray(path), \"module path must be a string or an Array.\")\n    delete this._runtimeModules[path.join('.')]\n    this._withCommit(function () {\n      var parentState = getNestedState(this$1.state, path.slice(0, -1))\n      Vue.delete(parentState, path[path.length - 1])\n    })\n    resetStore(this)\n  };\n\n  Store.prototype.hotUpdate = function hotUpdate (newOptions) {\n    var options = this._options\n    if (newOptions.actions) {\n      options.actions = newOptions.actions\n    }\n    if (newOptions.mutations) {\n      options.mutations = newOptions.mutations\n    }\n    if (newOptions.getters) {\n      options.getters = newOptions.getters\n    }\n    if (newOptions.modules) {\n      for (var key in newOptions.modules) {\n        options.modules[key] = newOptions.modules[key]\n      }\n    }\n    resetStore(this)\n  };\n\n  Store.prototype._withCommit = function _withCommit (fn) {\n    var committing = this._committing\n      this._committing = true\n    fn()\n    this._committing = committing\n  };\n\n  Object.defineProperties( Store.prototype, prototypeAccessors );\n\n  function assert (condition, msg) {\n    if (!condition) throw new Error((\"[vuex] \" + msg))\n  }\n\n  function resetStore (store) {\n    store._actions = Object.create(null)\n    store._mutations = Object.create(null)\n    store._wrappedGetters = Object.create(null)\n    var state = store.state\n    // init root module\n    installModule(store, state, [], store._options, true)\n    // init all runtime modules\n    Object.keys(store._runtimeModules).forEach(function (key) {\n      installModule(store, state, key.split('.'), store._runtimeModules[key], true)\n    })\n    // reset vm\n    resetStoreVM(store, state)\n  }\n\n  function resetStoreVM (store, state) {\n    var oldVm = store._vm\n\n    // bind store public getters\n    store.getters = {}\n    var wrappedGetters = store._wrappedGetters\n    var computed = {}\n    Object.keys(wrappedGetters).forEach(function (key) {\n      var fn = wrappedGetters[key]\n      // use computed to leverage its lazy-caching mechanism\n      computed[key] = function () { return fn(store); }\n      Object.defineProperty(store.getters, key, {\n        get: function () { return store._vm[key]; }\n      })\n    })\n\n    // use a Vue instance to store the state tree\n    // suppress warnings just in case the user has added\n    // some funky global mixins\n    var silent = Vue.config.silent\n    Vue.config.silent = true\n    store._vm = new Vue({\n      data: { state: state },\n      computed: computed\n    })\n    Vue.config.silent = silent\n\n    // enable strict mode for new vm\n    if (store.strict) {\n      enableStrictMode(store)\n    }\n\n    if (oldVm) {\n      // dispatch changes in all subscribed watchers\n      // to force getter re-evaluation.\n      store._withCommit(function () {\n        oldVm.state = null\n      })\n      Vue.nextTick(function () { return oldVm.$destroy(); })\n    }\n  }\n\n  function installModule (store, rootState, path, module, hot) {\n    var isRoot = !path.length\n    var state = module.state;\n    var actions = module.actions;\n    var mutations = module.mutations;\n    var getters = module.getters;\n    var modules = module.modules;\n\n    // set state\n    if (!isRoot && !hot) {\n      var parentState = getNestedState(rootState, path.slice(0, -1))\n      var moduleName = path[path.length - 1]\n      store._withCommit(function () {\n        Vue.set(parentState, moduleName, state || {})\n      })\n    }\n\n    if (mutations) {\n      Object.keys(mutations).forEach(function (key) {\n        registerMutation(store, key, mutations[key], path)\n      })\n    }\n\n    if (actions) {\n      Object.keys(actions).forEach(function (key) {\n        registerAction(store, key, actions[key], path)\n      })\n    }\n\n    if (getters) {\n      wrapGetters(store, getters, path)\n    }\n\n    if (modules) {\n      Object.keys(modules).forEach(function (key) {\n        installModule(store, rootState, path.concat(key), modules[key], hot)\n      })\n    }\n  }\n\n  function registerMutation (store, type, handler, path) {\n    if ( path === void 0 ) path = [];\n\n    var entry = store._mutations[type] || (store._mutations[type] = [])\n    entry.push(function wrappedMutationHandler (payload) {\n      handler(getNestedState(store.state, path), payload)\n    })\n  }\n\n  function registerAction (store, type, handler, path) {\n    if ( path === void 0 ) path = [];\n\n    var entry = store._actions[type] || (store._actions[type] = [])\n    var dispatch = store.dispatch;\n    var commit = store.commit;\n    entry.push(function wrappedActionHandler (payload, cb) {\n      var res = handler({\n        dispatch: dispatch,\n        commit: commit,\n        getters: store.getters,\n        state: getNestedState(store.state, path),\n        rootState: store.state\n      }, payload, cb)\n      if (!isPromise(res)) {\n        res = Promise.resolve(res)\n      }\n      if (store._devtoolHook) {\n        return res.catch(function (err) {\n          store._devtoolHook.emit('vuex:error', err)\n          throw err\n        })\n      } else {\n        return res\n      }\n    })\n  }\n\n  function wrapGetters (store, moduleGetters, modulePath) {\n    Object.keys(moduleGetters).forEach(function (getterKey) {\n      var rawGetter = moduleGetters[getterKey]\n      if (store._wrappedGetters[getterKey]) {\n        console.error((\"[vuex] duplicate getter key: \" + getterKey))\n        return\n      }\n      store._wrappedGetters[getterKey] = function wrappedGetter (store) {\n        return rawGetter(\n          getNestedState(store.state, modulePath), // local state\n          store.getters, // getters\n          store.state // root state\n        )\n      }\n    })\n  }\n\n  function enableStrictMode (store) {\n    store._vm.$watch('state', function () {\n      assert(store._committing, \"Do not mutate vuex store state outside mutation handlers.\")\n    }, { deep: true, sync: true })\n  }\n\n  function isObject (obj) {\n    return obj !== null && typeof obj === 'object'\n  }\n\n  function isPromise (val) {\n    return val && typeof val.then === 'function'\n  }\n\n  function getNestedState (state, path) {\n    return path.length\n      ? path.reduce(function (state, key) { return state[key]; }, state)\n      : state\n  }\n\n  function install (_Vue) {\n    if (Vue) {\n      console.error(\n        '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n      )\n      return\n    }\n    Vue = _Vue\n    applyMixin(Vue)\n  }\n\n  // auto install in dist mode\n  if (typeof window !== 'undefined' && window.Vue) {\n    install(window.Vue)\n  }\n\n  var index = {\n    Store: Store,\n    install: install,\n    mapState: mapState,\n    mapMutations: mapMutations,\n    mapGetters: mapGetters,\n    mapActions: mapActions\n  }\n\n  return index;\n\n}));\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vuex/dist/vuex.js\n ** module id = 48\n ** module chunks = 3\n **/\n//# sourceURL=webpack:///./~/vuex/dist/vuex.js?");

/***/ },

/***/ 51:
/*!*******************************************!*\
  !*** ./src/js/module/counter/Counter.vue ***!
  \*******************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("var __vue_exports__, __vue_options__\n\n/* script */\n__vue_exports__ = __webpack_require__(/*! !babel-loader!vue-loader/lib/selector?type=script&index=0!./Counter.vue */ 52)\n\n/* template */\nvar __vue_template__ = __webpack_require__(/*! !vue-loader/lib/template-compiler?id=data-v-14!vue-loader/lib/selector?type=template&index=0!./Counter.vue */ 53)\n__vue_options__ = __vue_exports__ = __vue_exports__ || {}\nif (typeof __vue_exports__.default === \"object\") {\nif (Object.keys(__vue_exports__).some(function (key) { return key !== \"default\" && key !== \"__esModule\" })) {console.error(\"named exports are not supported in *.vue files.\")}\n__vue_options__ = __vue_exports__ = __vue_exports__.default\n}\nif (typeof __vue_options__ === \"function\") {\n  __vue_options__ = __vue_options__.options\n}\n__vue_options__.render = __vue_template__.render\n__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-14\", __vue_options__)\n  } else {\n    hotAPI.reload(\"data-v-14\", __vue_options__)\n  }\n})()}\nif (__vue_options__.functional) {console.error(\"[vue-loader] Counter.vue: functional components are not supported and should be defined in plain js files using render functions.\")}\n\nmodule.exports = __vue_exports__\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/module/counter/Counter.vue\n ** module id = 51\n ** module chunks = 3\n **/\n//# sourceURL=webpack:///./src/js/module/counter/Counter.vue?");

/***/ },

/***/ 52:
/*!***************************************************************************************************************!*\
  !*** ./~/babel-loader!./~/vue-loader/lib/selector.js?type=script&index=0!./src/js/module/counter/Counter.vue ***!
  \***************************************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nexports.__esModule = true;\n\nvar _vuex = __webpack_require__(/*! vuex */ 48);\n\nexports['default'] = {\n  name: 'Counter',\n  computed: (0, _vuex.mapGetters)(['evenOrOdd']),\n  methods: (0, _vuex.mapActions)(['increment', 'decrement', 'incrementIfOdd', 'incrementAsync'])\n}; //\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nmodule.exports = exports['default'];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-loader!./~/vue-loader/lib/selector.js?type=script&index=0!./src/js/module/counter/Counter.vue\n ** module id = 52\n ** module chunks = 3\n **/\n//# sourceURL=webpack:///./src/js/module/counter/Counter.vue?./~/babel-loader!./~/vue-loader/lib/selector.js?type=script&index=0");

/***/ },

/***/ 53:
/*!*****************************************************************************************************************************************************!*\
  !*** ./~/vue-loader/lib/template-compiler.js?id=data-v-14!./~/vue-loader/lib/selector.js?type=template&index=0!./src/js/module/counter/Counter.vue ***!
  \*****************************************************************************************************************************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports={render:function (){with(this) {\n  return _h('div', {\n    attrs: {\n      \"id\": \"app\"\n    }\n  }, [\"\\n  Clicked: \" + _s($store.state.count) + \" times, count is \" + _s(evenOrOdd) + \"\\n  \", _h('button', {\n    staticClass: \"btn\",\n    attrs: {\n      \"type\": \"button\"\n    },\n    on: {\n      \"click\": increment\n    }\n  }, [\"+\"]), \" \", _h('button', {\n    staticClass: \"btn\",\n    attrs: {\n      \"type\": \"button\"\n    },\n    on: {\n      \"click\": decrement\n    }\n  }, [\"-\"]), \" \", _h('button', {\n    staticClass: \"btn\",\n    attrs: {\n      \"type\": \"button\"\n    },\n    on: {\n      \"click\": incrementIfOdd\n    }\n  }, [\"increment if odd\"]), \" \", _h('button', {\n    staticClass: \"btn\",\n    attrs: {\n      \"type\": \"button\"\n    },\n    on: {\n      \"click\": incrementAsync\n    }\n  }, [\" increment async\"])])\n}},staticRenderFns: []}\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-14\", module.exports)\n  }\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vue-loader/lib/template-compiler.js?id=data-v-14!./~/vue-loader/lib/selector.js?type=template&index=0!./src/js/module/counter/Counter.vue\n ** module id = 53\n ** module chunks = 3\n **/\n//# sourceURL=webpack:///./src/js/module/counter/Counter.vue?./~/vue-loader/lib/template-compiler.js?id=data-v-14!./~/vue-loader/lib/selector.js?type=template&index=0");

/***/ },

/***/ 54:
/*!****************************************!*\
  !*** ./src/js/module/counter/store.js ***!
  \****************************************/
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(Vue, Vuex) {'use strict';\n\nexports.__esModule = true;\nVue.use(Vuex);\n\nvar state = {\n  count: 0\n};\n\nvar mutations = {\n  increment: function increment(state) {\n    state.count++;\n  },\n  decrement: function decrement(state) {\n    state.count--;\n  }\n};\n\nvar actions = {\n  increment: function increment(_ref) {\n    var commit = _ref.commit;\n    return commit('increment');\n  },\n  decrement: function decrement(_ref2) {\n    var commit = _ref2.commit;\n    return commit('decrement');\n  },\n  incrementIfOdd: function incrementIfOdd(_ref3) {\n    var commit = _ref3.commit;\n    var state = _ref3.state;\n\n    if ((state.count + 1) % 2 === 0) {\n      commit('increment');\n    }\n  },\n  incrementAsync: function incrementAsync(_ref4) {\n    var commit = _ref4.commit;\n\n    return new Promise(function (resolve, reject) {\n      setTimeout(function () {\n        commit('increment');\n        resolve();\n      }, 1000);\n    });\n  }\n};\n\nvar getters = {\n  evenOrOdd: function evenOrOdd(state) {\n    return state % 2 === 0 ? 'even' : 'odd';\n  }\n};\n\nexports['default'] = new Vuex.Store({\n  state: state,\n  mutations: mutations,\n  actions: actions,\n  getters: getters\n});\nmodule.exports = exports['default'];\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! vue */ 1), __webpack_require__(/*! vuex */ 48)))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/js/module/counter/store.js\n ** module id = 54\n ** module chunks = 3\n **/\n//# sourceURL=webpack:///./src/js/module/counter/store.js?");

/***/ }

});